"""
Natural Language Query Engine for FinLens AI.
Uses pre-defined SQL templates with AI intent classification.
SECURITY: AI never generates SQL directly - only selects templates and extracts parameters.
PostgreSQL-only implementation.
"""

from __future__ import annotations

import re
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime, date, timedelta

import os

from services.gemini_client import get_gemini_client
from models import NLQueryResponse

# Currency settings from environment
CURRENCY_CODE = os.getenv("CURRENCY_CODE", "GHS")
CURRENCY_SYMBOL = os.getenv("CURRENCY_SYMBOL", "GHâ‚µ")


class QueryEngine:
    """
    Natural language query processor with SQL template security.
    
    Portfolio Differentiator: SQL-first approach prevents AI-generated SQL injection.
    PostgreSQL-only implementation with TO_CHAR for date formatting.
    """
    
    # Pre-defined PostgreSQL SQL templates (NEVER generated by AI)
    TEMPLATES = {
        "total_by_category": {
            "sql": """
                SELECT category, SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                GROUP BY category
                ORDER BY total DESC
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total spending by category"
        },
        "total_in_period": {
            "sql": """
                SELECT SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total spending in a time period"
        },
        "category_total": {
            "sql": """
                SELECT SUM(amount) as total, COUNT(*) as count
                FROM expenses
                WHERE user_id = $1 AND category = $2
                AND date >= $3 AND date <= $4
            """,
            "params": ["user_id", "category", "start_date", "end_date"],
            "description": "Total for specific category"
        },
        "highest_expenses": {
            "sql": """
                SELECT description, amount, category, date
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                ORDER BY amount DESC
                LIMIT $4
            """,
            "params": ["user_id", "start_date", "end_date", "limit"],
            "description": "Highest expenses in period"
        },
        "compare_months": {
            "sql": """
                SELECT 
                    TO_CHAR(date, 'YYYY-MM') as month,
                    SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                GROUP BY TO_CHAR(date, 'YYYY-MM')
                ORDER BY month
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Compare spending across months"
        },
        "budget_check": {
            "sql": """
                SELECT 
                    b.category,
                    b.monthly_limit,
                    COALESCE(SUM(e.amount), 0) as current_spending,
                    b.monthly_limit - COALESCE(SUM(e.amount), 0) as remaining
                FROM budgets b
                LEFT JOIN expenses e ON b.category = e.category
                    AND e.user_id = $1
                    AND TO_CHAR(e.date, 'YYYY-MM') = $2
                WHERE b.user_id = $1
                GROUP BY b.category, b.monthly_limit
            """,
            "params": ["user_id", "month"],
            "description": "Check budget status"
        }
    }
    
    def __init__(self):
        """Initialize query engine."""
        self.gemini_client = get_gemini_client()
    
    async def _classify_intent(self, query: str) -> Dict[str, Any]:
        """
        Classify user intent and extract parameters using AI.
        
        Returns template key and parameters (NOT SQL).
        """
        system_instruction = f"""You are a query intent classifier for a personal finance app.
Given a natural language query, identify:
1. Which SQL template to use (from the list below)
2. What parameters are needed

Available templates:
{chr(10).join(f"- {key}: {info['description']}" for key, info in self.TEMPLATES.items())}

Respond with JSON:
{{
  "template": "template_key",
  "category": "category name if mentioned",
  "time_period": "last 30 days|this month|last month|this week|etc",
  "limit": 10,
  "confidence": 0.85
}}
"""
        
        prompt = f"Classify this query: '{query}'"
        
        try:
            response = await self.gemini_client.generate_structured_content(
                prompt=prompt,
                system_instruction=system_instruction
            )
            
            return response
        except Exception as e:
            print(f"Intent classification failed: {e}")
            # Fallback to simple pattern matching
            return self._fallback_intent(query)
    
    def _fallback_intent(self, query: str) -> Dict[str, Any]:
        """Fallback intent classification using regex."""
        query_lower = query.lower()
        
        # Pattern matching for common queries
        if "total" in query_lower and "category" in query_lower:
            return {
                "template": "total_by_category",
                "time_period": "last 30 days",
                "confidence": 0.7
            }
        elif "highest" in query_lower or "top" in query_lower:
            return {
                "template": "highest_expenses",
                "time_period": "last 30 days",
                "limit": 10,
                "confidence": 0.7
            }
        elif "budget" in query_lower or "over" in query_lower:
            return {
                "template": "budget_check",
                "time_period": "this month",
                "confidence": 0.7
            }
        elif "food" in query_lower or "dining" in query_lower:
            return {
                "template": "category_total",
                "category": "Food & Dining",
                "time_period": "last 30 days",
                "confidence": 0.7
            }
        else:
            return {
                "template": "total_in_period",
                "time_period": "last 30 days",
                "confidence": 0.5
            }
    
    def _parse_time_period(self, period_str: str) -> Tuple[date, date]:
        """Convert time period string to start/end dates."""
        today = date.today()
        
        if "last 30 days" in period_str.lower():
            return (today - timedelta(days=30), today)
        elif "this month" in period_str.lower():
            return (date(today.year, today.month, 1), today)
        elif "last month" in period_str.lower():
            if today.month == 1:
                last_month = date(today.year - 1, 12, 1)
            else:
                last_month = date(today.year, today.month - 1, 1)
            # Last day of last month
            end_date = date(today.year, today.month, 1) - timedelta(days=1)
            return (last_month, end_date)
        elif "this week" in period_str.lower():
            start = today - timedelta(days=today.weekday())
            return (start, today)
        else:
            # Default to last 30 days
            return (today - timedelta(days=30), today)
    
    def _extract_params(self, intent: Dict[str, Any], user_id: int) -> Dict[str, Any]:
        """Extract and format parameters from intent."""
        params = {}
        
        # User ID is always required
        params["user_id"] = user_id
        
        # Time period
        if "time_period" in intent:
            start_date, end_date = self._parse_time_period(intent["time_period"])
            params["start_date"] = start_date
            params["end_date"] = end_date
        else:
            # Default to last 30 days
            today = date.today()
            params["start_date"] = today - timedelta(days=30)
            params["end_date"] = today
        
        # Category
        if "category" in intent and intent["category"]:
            params["category"] = intent["category"]
        
        # Limit
        if "limit" in intent:
            params["limit"] = intent["limit"]
        else:
            params["limit"] = 10
        
        # Month for budget check
        if intent.get("template") == "budget_check":
            today = date.today()
            params["month"] = f"{today.year}-{today.month:02d}"
        
        return params
    
    async def _execute_query(
        self,
        template_key: str,
        params: Dict[str, Any],
        db
    ) -> List[Dict[str, Any]]:
        """Execute PostgreSQL query with positional parameters."""
        template = self.TEMPLATES[template_key]
        sql = template["sql"]
        param_order = template["params"]
        
        # Build positional parameters tuple
        param_values = tuple(params.get(p) for p in param_order)
        
        # Execute query using positional parameters
        cursor = await db.execute(sql, param_values)
        rows = await cursor.fetchall()
        
        return [dict(row) for row in rows]
    
    async def _generate_explanation(
        self,
        query: str,
        results: List[Dict[str, Any]],
        template_key: str
    ) -> str:
        """Generate natural language explanation of results."""
        system_instruction = f"""You are a financial assistant explaining query results.
Be concise, clear, and helpful. Focus on insights, not just restating data.
Keep explanations under 2 sentences.
IMPORTANT: Always use {CURRENCY_CODE} ({CURRENCY_SYMBOL}) as the currency. Never use dollars ($) or any other currency."""
        
        prompt = f"""
Query: "{query}"
Template used: {template_key}
Results: {results[:5]}  # First 5 results

Explain these results in plain English.
"""
        
        try:
            explanation = await self.gemini_client.generate_content(
                prompt=prompt,
                system_instruction=system_instruction
            )
            return explanation
        except Exception:
            return f"Found {len(results)} results for your query."
    
    async def process_query(
        self,
        query: str,
        db,
        user_id: int
    ) -> NLQueryResponse:
        """
        Process natural language query end-to-end.
        
        Steps:
        1. Classify intent (AI)
        2. Select SQL template (pre-defined)
        3. Extract parameters (with user_id)
        4. Execute query
        5. Generate explanation (AI)
        """
        # Step 1: Classify intent
        intent = await self._classify_intent(query)
        template_key = intent.get("template", "total_in_period")
        
        # Step 2: Template already selected (from TEMPLATES dict)
        if template_key not in self.TEMPLATES:
            template_key = "total_in_period"  # Fallback
        
        # Step 3: Extract parameters (with user_id)
        params = self._extract_params(intent, user_id)
        
        # Step 4: Execute query
        results = await self._execute_query(template_key, params, db)
        
        # Step 5: Generate explanation
        explanation = await self._generate_explanation(query, results, template_key)
        
        return NLQueryResponse(
            query=query,
            intent=template_key,
            data={"results": results, "count": len(results)},
            explanation=explanation,
            sql_template_used=self.TEMPLATES[template_key]["description"],
            confidence=intent.get("confidence", 0.5)
        )


# Global query engine instance
_query_engine: Optional[QueryEngine] = None


def get_query_engine() -> QueryEngine:
    """Get or create query engine singleton."""
    global _query_engine
    if _query_engine is None:
        _query_engine = QueryEngine()
    return _query_engine
