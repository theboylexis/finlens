"""
Natural Language Query Engine for FinLens AI.
Uses pre-defined SQL templates with AI intent classification.
SECURITY: AI never generates SQL directly - only selects templates and extracts parameters.
PostgreSQL-only implementation.
"""

from __future__ import annotations

import re
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime, date, timedelta

import os

from services.gemini_client import get_gemini_client
from models import NLQueryResponse

# Currency settings from environment
CURRENCY_CODE = os.getenv("CURRENCY_CODE", "GHS")
CURRENCY_SYMBOL = os.getenv("CURRENCY_SYMBOL", "GHâ‚µ")


class QueryEngine:
    """
    Natural language query processor with SQL template security.
    
    Portfolio Differentiator: SQL-first approach prevents AI-generated SQL injection.
    PostgreSQL-only implementation with TO_CHAR for date formatting.
    """
    
    # Pre-defined PostgreSQL SQL templates (NEVER generated by AI)
    TEMPLATES = {
        # ========== EXPENSE TEMPLATES ==========
        "total_by_category": {
            "sql": """
                SELECT category, SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                GROUP BY category
                ORDER BY total DESC
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total spending by category"
        },
        "total_in_period": {
            "sql": """
                SELECT SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total spending in a time period"
        },
        "category_total": {
            "sql": """
                SELECT SUM(amount) as total, COUNT(*) as count
                FROM expenses
                WHERE user_id = $1 AND category = $2
                AND date >= $3 AND date <= $4
            """,
            "params": ["user_id", "category", "start_date", "end_date"],
            "description": "Total for specific category"
        },
        "highest_expenses": {
            "sql": """
                SELECT description, amount, category, date
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                ORDER BY amount DESC
                LIMIT $4
            """,
            "params": ["user_id", "start_date", "end_date", "limit"],
            "description": "Highest expenses in period"
        },
        "compare_months": {
            "sql": """
                SELECT 
                    TO_CHAR(date, 'YYYY-MM') as month,
                    SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                GROUP BY TO_CHAR(date, 'YYYY-MM')
                ORDER BY month
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Compare spending across months"
        },
        "budget_check": {
            "sql": """
                SELECT 
                    b.category,
                    b.monthly_limit,
                    COALESCE(SUM(e.amount), 0) as current_spending,
                    b.monthly_limit - COALESCE(SUM(e.amount), 0) as remaining
                FROM budgets b
                LEFT JOIN expenses e ON b.category = e.category
                    AND e.user_id = $1
                    AND TO_CHAR(e.date, 'YYYY-MM') = $2
                WHERE b.user_id = $1
                GROUP BY b.category, b.monthly_limit
            """,
            "params": ["user_id", "month"],
            "description": "Check budget status"
        },
        
        # ========== GOALS TEMPLATES ==========
        "goals_progress": {
            "sql": """
                SELECT 
                    name,
                    target_amount,
                    current_amount,
                    ROUND((current_amount / NULLIF(target_amount, 0) * 100)::numeric, 1) as progress_percent,
                    target_date,
                    is_completed
                FROM savings_goals
                WHERE user_id = $1 AND is_completed = FALSE
                ORDER BY target_date ASC NULLS LAST
            """,
            "params": ["user_id"],
            "description": "Progress on savings goals"
        },
        "goals_total_saved": {
            "sql": """
                SELECT 
                    SUM(gc.amount) as total_saved,
                    COUNT(gc.id) as contribution_count
                FROM goal_contributions gc
                JOIN savings_goals sg ON gc.goal_id = sg.id
                WHERE sg.user_id = $1 
                AND gc.created_at >= $2 AND gc.created_at <= $3
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total saved towards goals in period"
        },
        "goals_on_track": {
            "sql": """
                SELECT 
                    name,
                    target_amount,
                    current_amount,
                    target_date,
                    CASE 
                        WHEN target_date IS NULL THEN 'No deadline'
                        WHEN current_amount >= target_amount THEN 'Completed'
                        WHEN target_date <= CURRENT_DATE THEN 'Overdue'
                        WHEN (current_amount / NULLIF(target_amount, 0)) >= 
                             (1.0 - (target_date - CURRENT_DATE)::float / 
                              GREATEST((target_date - created_at::date)::float, 1)) THEN 'On track'
                        ELSE 'Behind'
                    END as status
                FROM savings_goals
                WHERE user_id = $1 AND is_completed = FALSE
            """,
            "params": ["user_id"],
            "description": "Check if goals are on track"
        },
        
        # ========== INCOME TEMPLATES ==========
        "income_total": {
            "sql": """
                SELECT 
                    SUM(amount) as total_income,
                    COUNT(*) as income_count
                FROM incomes
                WHERE user_id = $1 AND date >= $2 AND date <= $3
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total income in period"
        },
        "income_vs_expenses": {
            "sql": """
                SELECT 
                    COALESCE((SELECT SUM(amount) FROM incomes WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as income,
                    COALESCE((SELECT SUM(amount) FROM expenses WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as expenses,
                    COALESCE((SELECT SUM(amount) FROM incomes WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) -
                    COALESCE((SELECT SUM(amount) FROM expenses WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as net
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Income vs expenses comparison"
        },
        "income_by_source": {
            "sql": """
                SELECT 
                    source,
                    category,
                    SUM(amount) as total
                FROM incomes
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                GROUP BY source, category
                ORDER BY total DESC
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Income breakdown by source"
        },
        "savings_potential": {
            "sql": """
                SELECT 
                    COALESCE((SELECT SUM(amount) FROM incomes WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as income,
                    COALESCE((SELECT SUM(amount) FROM expenses WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as expenses,
                    COALESCE((SELECT SUM(monthly_limit) FROM budgets WHERE user_id = $1), 0) as budget_limits
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Calculate savings potential"
        },
        
        # ========== SUBSCRIPTION TEMPLATES ==========
        "subscriptions_monthly_total": {
            "sql": """
                SELECT 
                    SUM(CASE 
                        WHEN billing_cycle = 'monthly' THEN amount
                        WHEN billing_cycle = 'yearly' THEN amount / 12
                        WHEN billing_cycle = 'weekly' THEN amount * 4.33
                        ELSE amount
                    END) as monthly_total,
                    COUNT(*) as subscription_count
                FROM subscriptions
                WHERE user_id = $1 AND is_active = TRUE
            """,
            "params": ["user_id"],
            "description": "Monthly subscription cost"
        },
        "subscriptions_upcoming": {
            "sql": """
                SELECT 
                    name,
                    amount,
                    billing_cycle,
                    next_renewal,
                    (next_renewal - CURRENT_DATE) as days_until
                FROM subscriptions
                WHERE user_id = $1 AND is_active = TRUE
                AND next_renewal >= CURRENT_DATE
                AND next_renewal <= CURRENT_DATE + INTERVAL '30 days'
                ORDER BY next_renewal ASC
            """,
            "params": ["user_id"],
            "description": "Upcoming subscription renewals"
        },
        "subscriptions_annual_cost": {
            "sql": """
                SELECT 
                    SUM(CASE 
                        WHEN billing_cycle = 'monthly' THEN amount * 12
                        WHEN billing_cycle = 'yearly' THEN amount
                        WHEN billing_cycle = 'weekly' THEN amount * 52
                        ELSE amount * 12
                    END) as annual_total,
                    COUNT(*) as subscription_count
                FROM subscriptions
                WHERE user_id = $1 AND is_active = TRUE
            """,
            "params": ["user_id"],
            "description": "Annual subscription cost"
        },
        
        # ========== SPLITS TEMPLATES ==========
        "splits_owed_to_me": {
            "sql": """
                SELECT 
                    f.name as friend_name,
                    SUM(es.amount) as amount_owed
                FROM expense_splits es
                JOIN friends f ON es.friend_id = f.id
                JOIN expenses e ON es.expense_id = e.id
                WHERE e.user_id = $1 AND es.is_settled = FALSE
                GROUP BY f.name
                ORDER BY amount_owed DESC
            """,
            "params": ["user_id"],
            "description": "Money owed to you by friends"
        },
        "splits_total_pending": {
            "sql": """
                SELECT 
                    SUM(es.amount) as total_pending,
                    COUNT(es.id) as split_count
                FROM expense_splits es
                JOIN expenses e ON es.expense_id = e.id
                WHERE e.user_id = $1 AND es.is_settled = FALSE
            """,
            "params": ["user_id"],
            "description": "Total pending settlements"
        },
        "splits_all_friends": {
            "sql": """
                SELECT 
                    f.name,
                    COALESCE(SUM(CASE WHEN es.is_settled = FALSE THEN es.amount ELSE 0 END), 0) as pending,
                    COALESCE(SUM(CASE WHEN es.is_settled = TRUE THEN es.amount ELSE 0 END), 0) as settled
                FROM friends f
                LEFT JOIN expense_splits es ON f.id = es.friend_id
                WHERE f.user_id = $1
                GROUP BY f.name
                ORDER BY pending DESC
            """,
            "params": ["user_id"],
            "description": "Split status with all friends"
        }
    }

    
    def __init__(self):
        """Initialize query engine."""
        self.gemini_client = get_gemini_client()
    
    async def _classify_intent(self, query: str) -> Dict[str, Any]:
        """
        Classify user intent and extract parameters using AI.
        
        Returns template key and parameters (NOT SQL).
        """
        system_instruction = f"""You are a query intent classifier for a personal finance app.
Given a natural language query, identify:
1. Which SQL template to use (from the list below)
2. What parameters are needed

Available templates:
{chr(10).join(f"- {key}: {info['description']}" for key, info in self.TEMPLATES.items())}

Respond with JSON:
{{
  "template": "template_key",
  "category": "category name if mentioned",
  "time_period": "last 30 days|this month|last month|this week|etc",
  "limit": 10,
  "confidence": 0.85
}}
"""
        
        prompt = f"Classify this query: '{query}'"
        
        try:
            response = await self.gemini_client.generate_structured_content(
                prompt=prompt,
                system_instruction=system_instruction
            )
            
            return response
        except Exception as e:
            print(f"Intent classification failed: {e}")
            # Fallback to simple pattern matching
            return self._fallback_intent(query)
    
    def _fallback_intent(self, query: str) -> Dict[str, Any]:
        """Fallback intent classification using regex."""
        query_lower = query.lower()
        
        # ========== GOALS PATTERNS ==========
        if any(word in query_lower for word in ["goal", "saving", "saved", "progress"]):
            if "track" in query_lower or "on track" in query_lower:
                return {
                    "template": "goals_on_track",
                    "confidence": 0.75
                }
            elif "total" in query_lower or "saved" in query_lower:
                return {
                    "template": "goals_total_saved",
                    "time_period": "this month",
                    "confidence": 0.75
                }
            else:
                return {
                    "template": "goals_progress",
                    "confidence": 0.75
                }
        
        # ========== INCOME PATTERNS ==========
        elif any(word in query_lower for word in ["income", "earn", "salary", "paycheck"]):
            if "vs" in query_lower or "versus" in query_lower or "compare" in query_lower:
                return {
                    "template": "income_vs_expenses",
                    "time_period": "this month",
                    "confidence": 0.75
                }
            elif "save" in query_lower or "potential" in query_lower:
                return {
                    "template": "savings_potential",
                    "time_period": "this month",
                    "confidence": 0.75
                }
            elif "source" in query_lower or "breakdown" in query_lower:
                return {
                    "template": "income_by_source",
                    "time_period": "this month",
                    "confidence": 0.75
                }
            else:
                return {
                    "template": "income_total",
                    "time_period": "this month",
                    "confidence": 0.75
                }
        
        # ========== SUBSCRIPTION PATTERNS ==========
        elif any(word in query_lower for word in ["subscription", "recurring", "renewal"]):
            if "annual" in query_lower or "yearly" in query_lower or "year" in query_lower:
                return {
                    "template": "subscriptions_annual_cost",
                    "confidence": 0.75
                }
            elif "upcoming" in query_lower or "next" in query_lower or "due" in query_lower:
                return {
                    "template": "subscriptions_upcoming",
                    "confidence": 0.75
                }
            else:
                return {
                    "template": "subscriptions_monthly_total",
                    "confidence": 0.75
                }
        
        # ========== SPLITS PATTERNS ==========
        elif any(word in query_lower for word in ["owe", "owes", "owed", "split", "friend", "settle"]):
            if "who" in query_lower or "owes me" in query_lower:
                return {
                    "template": "splits_owed_to_me",
                    "confidence": 0.75
                }
            elif "pending" in query_lower or "total" in query_lower:
                return {
                    "template": "splits_total_pending",
                    "confidence": 0.75
                }
            else:
                return {
                    "template": "splits_all_friends",
                    "confidence": 0.75
                }
        
        # ========== EXPENSE PATTERNS (original) ==========
        elif "total" in query_lower and "category" in query_lower:
            return {
                "template": "total_by_category",
                "time_period": "last 30 days",
                "confidence": 0.7
            }
        elif "highest" in query_lower or "top" in query_lower or "biggest" in query_lower:
            return {
                "template": "highest_expenses",
                "time_period": "last 30 days",
                "limit": 10,
                "confidence": 0.7
            }
        elif "budget" in query_lower or "over budget" in query_lower:
            return {
                "template": "budget_check",
                "time_period": "this month",
                "confidence": 0.7
            }
        elif "food" in query_lower or "dining" in query_lower:
            return {
                "template": "category_total",
                "category": "Food & Dining",
                "time_period": "last 30 days",
                "confidence": 0.7
            }
        elif "spent" in query_lower or "spending" in query_lower or "expense" in query_lower:
            return {
                "template": "total_in_period",
                "time_period": "last 30 days",
                "confidence": 0.6
            }
        else:
            # Default fallback - try to be helpful
            return {
                "template": "total_in_period",
                "time_period": "last 30 days",
                "confidence": 0.4
            }

    
    def _parse_time_period(self, period_str: str) -> Tuple[date, date]:
        """Convert time period string to start/end dates."""
        today = date.today()
        
        if "last 30 days" in period_str.lower():
            return (today - timedelta(days=30), today)
        elif "this month" in period_str.lower():
            return (date(today.year, today.month, 1), today)
        elif "last month" in period_str.lower():
            if today.month == 1:
                last_month = date(today.year - 1, 12, 1)
            else:
                last_month = date(today.year, today.month - 1, 1)
            # Last day of last month
            end_date = date(today.year, today.month, 1) - timedelta(days=1)
            return (last_month, end_date)
        elif "this week" in period_str.lower():
            start = today - timedelta(days=today.weekday())
            return (start, today)
        else:
            # Default to last 30 days
            return (today - timedelta(days=30), today)
    
    def _extract_params(self, intent: Dict[str, Any], user_id: int) -> Dict[str, Any]:
        """Extract and format parameters from intent."""
        params = {}
        template_key = intent.get("template", "total_in_period")
        
        # User ID is always required
        params["user_id"] = user_id
        
        # Get template to check required params
        template = self.TEMPLATES.get(template_key, {})
        required_params = template.get("params", [])
        
        # Time period - only add if template requires it
        if "start_date" in required_params or "end_date" in required_params:
            if "time_period" in intent:
                start_date, end_date = self._parse_time_period(intent["time_period"])
                params["start_date"] = start_date
                params["end_date"] = end_date
            else:
                # Default to last 30 days
                today = date.today()
                params["start_date"] = today - timedelta(days=30)
                params["end_date"] = today
        
        # Category
        if "category" in required_params:
            if "category" in intent and intent["category"]:
                params["category"] = intent["category"]
            else:
                params["category"] = "Other"  # Default category
        
        # Limit
        if "limit" in required_params:
            if "limit" in intent:
                params["limit"] = intent["limit"]
            else:
                params["limit"] = 10
        
        # Month for budget check
        if "month" in required_params:
            today = date.today()
            params["month"] = f"{today.year}-{today.month:02d}"
        
        return params

    
    async def _execute_query(
        self,
        template_key: str,
        params: Dict[str, Any],
        db
    ) -> List[Dict[str, Any]]:
        """Execute PostgreSQL query with positional parameters."""
        template = self.TEMPLATES[template_key]
        sql = template["sql"]
        param_order = template["params"]
        
        # Build positional parameters tuple
        param_values = tuple(params.get(p) for p in param_order)
        
        # Execute query using positional parameters
        cursor = await db.execute(sql, param_values)
        rows = await cursor.fetchall()
        
        return [dict(row) for row in rows]
    
    async def _generate_explanation(
        self,
        query: str,
        results: List[Dict[str, Any]],
        template_key: str
    ) -> str:
        """Generate natural language explanation of results."""
        
        # Try to generate a smart fallback first in case Gemini fails
        fallback = self._generate_fallback_explanation(results, template_key)
        
        system_instruction = f"""You are a financial assistant explaining query results.
Be concise, clear, and helpful. Focus on insights, not just restating data.
Keep explanations to 1-2 sentences maximum.
IMPORTANT: Always use {CURRENCY_CODE} ({CURRENCY_SYMBOL}) as the currency. Never use dollars ($) or any other currency.
If there's no data, say so helpfully."""
        
        prompt = f"""
Query: "{query}"
Template: {template_key}
Data: {results[:5]}

Explain these financial results in plain English. Be specific with numbers.
"""
        
        try:
            explanation = await self.gemini_client.generate_content(
                prompt=prompt,
                system_instruction=system_instruction
            )
            # If Gemini returns something too generic or short, use fallback
            if len(explanation) < 20 or "result" in explanation.lower():
                return fallback
            return explanation
        except Exception:
            return fallback
    
    def _generate_fallback_explanation(
        self,
        results: List[Dict[str, Any]],
        template_key: str
    ) -> str:
        """Generate template-specific fallback explanations."""
        if not results:
            return "No data found for this query. Try adding some records first!"
        
        row = results[0]  # First result
        
        # Template-specific explanations
        if template_key == "savings_potential":
            income = float(row.get("income", 0) or 0)
            expenses = float(row.get("expenses", 0) or 0)
            net = income - expenses
            if net > 0:
                return f"Based on {CURRENCY_SYMBOL}{income:,.2f} income and {CURRENCY_SYMBOL}{expenses:,.2f} expenses, you could save {CURRENCY_SYMBOL}{net:,.2f} this month."
            elif net < 0:
                return f"You're spending {CURRENCY_SYMBOL}{abs(net):,.2f} more than you earn. Consider reducing expenses."
            else:
                return "Your income and expenses are balanced. No extra savings available."
        
        elif template_key == "income_total":
            total = float(row.get("total_income", 0) or 0)
            count = int(row.get("income_count", 0) or 0)
            return f"Total income: {CURRENCY_SYMBOL}{total:,.2f} from {count} source(s)."
        
        elif template_key == "income_vs_expenses":
            income = float(row.get("income", 0) or 0)
            expenses = float(row.get("expenses", 0) or 0)
            net = float(row.get("net", 0) or 0)
            status = "surplus" if net >= 0 else "deficit"
            return f"Income: {CURRENCY_SYMBOL}{income:,.2f}, Expenses: {CURRENCY_SYMBOL}{expenses:,.2f}. Net {status}: {CURRENCY_SYMBOL}{abs(net):,.2f}."
        
        elif template_key == "goals_progress":
            goals_info = []
            for g in results[:3]:
                name = g.get("name", "Goal")
                progress = float(g.get("progress_percent", 0) or 0)
                goals_info.append(f"{name}: {progress:.0f}%")
            return "Goal progress: " + ", ".join(goals_info) if goals_info else "No active goals found."
        
        elif template_key == "goals_on_track":
            statuses = [f"{r.get('name')}: {r.get('status')}" for r in results[:3]]
            return "Goal status: " + ", ".join(statuses) if statuses else "No active goals."
        
        elif template_key == "goals_total_saved":
            total = float(row.get("total_saved", 0) or 0)
            return f"You've saved {CURRENCY_SYMBOL}{total:,.2f} towards your goals this period."
        
        elif template_key == "subscriptions_monthly_total":
            total = float(row.get("monthly_total", 0) or 0)
            count = int(row.get("subscription_count", 0) or 0)
            return f"Your {count} active subscription(s) cost {CURRENCY_SYMBOL}{total:,.2f}/month."
        
        elif template_key == "subscriptions_annual_cost":
            total = float(row.get("annual_total", 0) or 0)
            return f"Your subscriptions will cost approximately {CURRENCY_SYMBOL}{total:,.2f} per year."
        
        elif template_key == "subscriptions_upcoming":
            if results:
                upcoming = [f"{r.get('name')} in {r.get('days_until')} days" for r in results[:3]]
                return "Upcoming renewals: " + ", ".join(upcoming)
            return "No upcoming subscription renewals in the next 30 days."
        
        elif template_key == "splits_owed_to_me":
            if results:
                owes = [f"{r.get('friend_name')}: {CURRENCY_SYMBOL}{float(r.get('amount_owed', 0)):,.2f}" for r in results[:3]]
                return "Friends who owe you: " + ", ".join(owes)
            return "No one owes you money right now."
        
        elif template_key == "splits_total_pending":
            total = float(row.get("total_pending", 0) or 0)
            count = int(row.get("split_count", 0) or 0)
            return f"You have {CURRENCY_SYMBOL}{total:,.2f} pending across {count} split(s)."
        
        elif template_key == "total_in_period":
            total = float(row.get("total", 0) or 0)
            return f"Total spending: {CURRENCY_SYMBOL}{total:,.2f}."
        
        elif template_key == "highest_expenses":
            if results:
                top = results[0]
                return f"Your biggest expense: {top.get('description', 'Unknown')} at {CURRENCY_SYMBOL}{float(top.get('amount', 0)):,.2f} ({top.get('category', 'Other')})."
            return "No expenses found in this period."
        
        elif template_key == "budget_check":
            over_budget = [r for r in results if float(r.get("remaining", 0) or 0) < 0]
            if over_budget:
                categories = ", ".join([r.get("category", "Unknown") for r in over_budget[:3]])
                return f"You're over budget in: {categories}."
            return "All budgets are on track!"
        
        # Default fallback
        return f"Found {len(results)} result(s) for your query."

    
    async def process_query(
        self,
        query: str,
        db,
        user_id: int
    ) -> NLQueryResponse:
        """
        Process natural language query end-to-end.
        
        Steps:
        1. Classify intent (AI)
        2. Select SQL template (pre-defined)
        3. Extract parameters (with user_id)
        4. Execute query
        5. Generate explanation (AI)
        """
        # Step 1: Classify intent
        intent = await self._classify_intent(query)
        template_key = intent.get("template", "total_in_period")
        
        # Step 2: Template already selected (from TEMPLATES dict)
        if template_key not in self.TEMPLATES:
            template_key = "total_in_period"  # Fallback
        
        # Step 3: Extract parameters (with user_id)
        params = self._extract_params(intent, user_id)
        
        # Step 4: Execute query
        results = await self._execute_query(template_key, params, db)
        
        # Step 5: Generate explanation
        explanation = await self._generate_explanation(query, results, template_key)
        
        return NLQueryResponse(
            query=query,
            intent=template_key,
            data={"results": results, "count": len(results)},
            explanation=explanation,
            sql_template_used=self.TEMPLATES[template_key]["description"],
            confidence=intent.get("confidence", 0.5)
        )


# Global query engine instance
_query_engine: Optional[QueryEngine] = None


def get_query_engine() -> QueryEngine:
    """Get or create query engine singleton."""
    global _query_engine
    if _query_engine is None:
        _query_engine = QueryEngine()
    return _query_engine
