"""
Natural Language Query Engine for FinLens AI.
Uses pre-defined SQL templates with AI intent classification.
SECURITY: AI never generates SQL directly - only selects templates and extracts parameters.
PostgreSQL-only implementation.

HYBRID QUERY SYSTEM:
- Data queries → SQL templates (secure, fast)
- Conversational queries → Gemini AI with user context (advice, planning, explanations)
"""

from __future__ import annotations

import re
from typing import Dict, Any, Optional, List, Tuple
from datetime import datetime, date, timedelta

import os

from services.gemini_client import get_gemini_client
from models import NLQueryResponse

# Currency settings from environment
CURRENCY_CODE = os.getenv("CURRENCY_CODE", "GHS")
CURRENCY_SYMBOL = os.getenv("CURRENCY_SYMBOL", "GH₵")

# Query type classification keywords
DATA_QUERY_KEYWORDS = [
    "how much", "total", "spent", "spending", "show me", "list", "compare", 
    "highest", "lowest", "top", "biggest", "what did i", "my expenses",
    "budget status", "over budget", "owed", "owes", "subscription cost",
    "income this", "saved this", "goal progress"
]

CONVERSATIONAL_KEYWORDS = [
    "create", "plan", "help me", "suggest", "recommend", "should i", 
    "can i afford", "how do i", "how can i", "what is", "explain", 
    "tips", "advice", "strategy", "ways to", "ideas", "feasible",
    "best way", "good idea", "make a", "give me a", "design",
    "college student", "save money", "reduce", "cut down", "improve"
]


class QueryEngine:
    """
    Natural language query processor with SQL template security.
    
    Portfolio Differentiator: SQL-first approach prevents AI-generated SQL injection.
    PostgreSQL-only implementation with TO_CHAR for date formatting.
    """
    
    # Pre-defined PostgreSQL SQL templates (NEVER generated by AI)
    TEMPLATES = {
        # ========== EXPENSE TEMPLATES ==========
        "total_by_category": {
            "sql": """
                SELECT category, SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                GROUP BY category
                ORDER BY total DESC
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total spending by category"
        },
        "total_in_period": {
            "sql": """
                SELECT SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total spending in a time period"
        },
        "category_total": {
            "sql": """
                SELECT SUM(amount) as total, COUNT(*) as count
                FROM expenses
                WHERE user_id = $1 AND category = $2
                AND date >= $3 AND date <= $4
            """,
            "params": ["user_id", "category", "start_date", "end_date"],
            "description": "Total for specific category"
        },
        "highest_expenses": {
            "sql": """
                SELECT description, amount, category, date
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                ORDER BY amount DESC
                LIMIT $4
            """,
            "params": ["user_id", "start_date", "end_date", "limit"],
            "description": "Highest expenses in period"
        },
        "compare_months": {
            "sql": """
                SELECT 
                    TO_CHAR(date, 'YYYY-MM') as month,
                    SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                GROUP BY TO_CHAR(date, 'YYYY-MM')
                ORDER BY month
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Compare spending across months"
        },
        "budget_check": {
            "sql": """
                SELECT 
                    b.category,
                    b.monthly_limit,
                    COALESCE(SUM(e.amount), 0) as current_spending,
                    b.monthly_limit - COALESCE(SUM(e.amount), 0) as remaining
                FROM budgets b
                LEFT JOIN expenses e ON b.category = e.category
                    AND e.user_id = $1
                    AND TO_CHAR(e.date, 'YYYY-MM') = $2
                WHERE b.user_id = $1
                GROUP BY b.category, b.monthly_limit
            """,
            "params": ["user_id", "month"],
            "description": "Check budget status"
        },
        
        # ========== GOALS TEMPLATES ==========
        "goals_progress": {
            "sql": """
                SELECT 
                    name,
                    target_amount,
                    current_amount,
                    ROUND((current_amount / NULLIF(target_amount, 0) * 100)::numeric, 1) as progress_percent,
                    target_date,
                    is_completed
                FROM savings_goals
                WHERE user_id = $1 AND is_completed = FALSE
                ORDER BY target_date ASC NULLS LAST
            """,
            "params": ["user_id"],
            "description": "Progress on savings goals"
        },
        "goals_total_saved": {
            "sql": """
                SELECT 
                    SUM(gc.amount) as total_saved,
                    COUNT(gc.id) as contribution_count
                FROM goal_contributions gc
                JOIN savings_goals sg ON gc.goal_id = sg.id
                WHERE sg.user_id = $1 
                AND gc.created_at >= $2 AND gc.created_at <= $3
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total saved towards goals in period"
        },
        "goals_on_track": {
            "sql": """
                SELECT 
                    name,
                    target_amount,
                    current_amount,
                    target_date,
                    CASE 
                        WHEN target_date IS NULL THEN 'No deadline'
                        WHEN current_amount >= target_amount THEN 'Completed'
                        WHEN target_date <= CURRENT_DATE THEN 'Overdue'
                        WHEN (current_amount / NULLIF(target_amount, 0)) >= 
                             (1.0 - (target_date - CURRENT_DATE)::float / 
                              GREATEST((target_date - created_at::date)::float, 1)) THEN 'On track'
                        ELSE 'Behind'
                    END as status
                FROM savings_goals
                WHERE user_id = $1 AND is_completed = FALSE
            """,
            "params": ["user_id"],
            "description": "Check if goals are on track"
        },
        
        # ========== INCOME TEMPLATES ==========
        "income_total": {
            "sql": """
                SELECT 
                    SUM(amount) as total_income,
                    COUNT(*) as income_count
                FROM incomes
                WHERE user_id = $1 AND date >= $2 AND date <= $3
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Total income in period"
        },
        "income_vs_expenses": {
            "sql": """
                SELECT 
                    COALESCE((SELECT SUM(amount) FROM incomes WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as income,
                    COALESCE((SELECT SUM(amount) FROM expenses WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as expenses,
                    COALESCE((SELECT SUM(amount) FROM incomes WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) -
                    COALESCE((SELECT SUM(amount) FROM expenses WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as net
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Income vs expenses comparison"
        },
        "income_by_source": {
            "sql": """
                SELECT 
                    source,
                    category,
                    SUM(amount) as total
                FROM incomes
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                GROUP BY source, category
                ORDER BY total DESC
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Income breakdown by source"
        },
        "savings_potential": {
            "sql": """
                SELECT 
                    COALESCE((SELECT SUM(amount) FROM incomes WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as income,
                    COALESCE((SELECT SUM(amount) FROM expenses WHERE user_id = $1 AND date >= $2 AND date <= $3), 0) as expenses,
                    COALESCE((SELECT SUM(monthly_limit) FROM budgets WHERE user_id = $1), 0) as budget_limits
            """,
            "params": ["user_id", "start_date", "end_date"],
            "description": "Calculate savings potential"
        },
        
        # ========== SUBSCRIPTION TEMPLATES ==========
        "subscriptions_monthly_total": {
            "sql": """
                SELECT 
                    SUM(CASE 
                        WHEN billing_cycle = 'monthly' THEN amount
                        WHEN billing_cycle = 'yearly' THEN amount / 12
                        WHEN billing_cycle = 'weekly' THEN amount * 4.33
                        ELSE amount
                    END) as monthly_total,
                    COUNT(*) as subscription_count
                FROM subscriptions
                WHERE user_id = $1 AND is_active = TRUE
            """,
            "params": ["user_id"],
            "description": "Monthly subscription cost"
        },
        "subscriptions_upcoming": {
            "sql": """
                SELECT 
                    name,
                    amount,
                    billing_cycle,
                    next_renewal,
                    (next_renewal - CURRENT_DATE) as days_until
                FROM subscriptions
                WHERE user_id = $1 AND is_active = TRUE
                AND next_renewal >= CURRENT_DATE
                AND next_renewal <= CURRENT_DATE + INTERVAL '30 days'
                ORDER BY next_renewal ASC
            """,
            "params": ["user_id"],
            "description": "Upcoming subscription renewals"
        },
        "subscriptions_annual_cost": {
            "sql": """
                SELECT 
                    SUM(CASE 
                        WHEN billing_cycle = 'monthly' THEN amount * 12
                        WHEN billing_cycle = 'yearly' THEN amount
                        WHEN billing_cycle = 'weekly' THEN amount * 52
                        ELSE amount * 12
                    END) as annual_total,
                    COUNT(*) as subscription_count
                FROM subscriptions
                WHERE user_id = $1 AND is_active = TRUE
            """,
            "params": ["user_id"],
            "description": "Annual subscription cost"
        },
        
        # ========== SPLITS TEMPLATES ==========
        "splits_owed_to_me": {
            "sql": """
                SELECT 
                    f.name as friend_name,
                    SUM(es.amount) as amount_owed
                FROM expense_splits es
                JOIN friends f ON es.friend_id = f.id
                JOIN expenses e ON es.expense_id = e.id
                WHERE e.user_id = $1 AND es.is_settled = FALSE
                GROUP BY f.name
                ORDER BY amount_owed DESC
            """,
            "params": ["user_id"],
            "description": "Money owed to you by friends"
        },
        "splits_total_pending": {
            "sql": """
                SELECT 
                    SUM(es.amount) as total_pending,
                    COUNT(es.id) as split_count
                FROM expense_splits es
                JOIN expenses e ON es.expense_id = e.id
                WHERE e.user_id = $1 AND es.is_settled = FALSE
            """,
            "params": ["user_id"],
            "description": "Total pending settlements"
        },
        "splits_all_friends": {
            "sql": """
                SELECT 
                    f.name,
                    COALESCE(SUM(CASE WHEN es.is_settled = FALSE THEN es.amount ELSE 0 END), 0) as pending,
                    COALESCE(SUM(CASE WHEN es.is_settled = TRUE THEN es.amount ELSE 0 END), 0) as settled
                FROM friends f
                LEFT JOIN expense_splits es ON f.id = es.friend_id
                WHERE f.user_id = $1
                GROUP BY f.name
                ORDER BY pending DESC
            """,
            "params": ["user_id"],
            "description": "Split status with all friends"
        }
    }

    
    def __init__(self):
        """Initialize query engine."""
        self.gemini_client = get_gemini_client()
    
    def _classify_query_type(self, query: str) -> str:
        """
        Classify whether the query is a data query or conversational query.
        
        Returns:
            "data" - User wants to query their actual financial data
            "conversational" - User wants advice, planning, explanations
        """
        query_lower = query.lower()
        
        # Count matches for each type
        data_score = sum(1 for keyword in DATA_QUERY_KEYWORDS if keyword in query_lower)
        conversational_score = sum(1 for keyword in CONVERSATIONAL_KEYWORDS if keyword in query_lower)
        
        # If conversational keywords are present and score higher, it's conversational
        if conversational_score > 0 and conversational_score >= data_score:
            return "conversational"
        
        # If data keywords are present, it's a data query
        if data_score > 0:
            return "data"
        
        # Default: try data query first (maintains backward compatibility)
        # But if the query is long and looks like a request, treat as conversational
        if len(query.split()) > 8 and any(word in query_lower for word in ["i want", "i need", "please", "for me"]):
            return "conversational"
        
        return "data"
    
    async def _get_user_financial_context(self, db, user_id: int) -> Dict[str, Any]:
        """
        Fetch user's financial context for personalized AI responses.
        
        Returns summary of income, expenses, budgets, goals, subscriptions.
        """
        context = {}
        today = date.today()
        month_start = date(today.year, today.month, 1)
        
        try:
            # Get monthly income
            cursor = await db.execute("""
                SELECT COALESCE(SUM(amount), 0) as total
                FROM incomes
                WHERE user_id = $1 AND date >= $2 AND date <= $3
            """, (user_id, month_start, today))
            row = await cursor.fetchone()
            context["monthly_income"] = float(row["total"]) if row else 0
            
            # Get monthly expenses
            cursor = await db.execute("""
                SELECT COALESCE(SUM(amount), 0) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
            """, (user_id, month_start, today))
            row = await cursor.fetchone()
            context["monthly_expenses"] = float(row["total"]) if row else 0
            
            # Get spending by category
            cursor = await db.execute("""
                SELECT category, SUM(amount) as total
                FROM expenses
                WHERE user_id = $1 AND date >= $2 AND date <= $3
                GROUP BY category
                ORDER BY total DESC
                LIMIT 5
            """, (user_id, month_start, today))
            rows = await cursor.fetchall()
            context["top_categories"] = [{"category": r["category"], "amount": float(r["total"])} for r in rows]
            
            # Get budget limits
            cursor = await db.execute("""
                SELECT category, monthly_limit
                FROM budgets
                WHERE user_id = $1
            """, (user_id,))
            rows = await cursor.fetchall()
            context["budgets"] = [{"category": r["category"], "limit": float(r["monthly_limit"])} for r in rows]
            context["total_budget_limit"] = sum(float(r["monthly_limit"]) for r in rows)
            
            # Get active goals
            cursor = await db.execute("""
                SELECT name, target_amount, current_amount, target_date
                FROM savings_goals
                WHERE user_id = $1 AND is_completed = FALSE
                LIMIT 3
            """, (user_id,))
            rows = await cursor.fetchall()
            context["goals"] = [
                {
                    "name": r["name"],
                    "target": float(r["target_amount"]),
                    "current": float(r["current_amount"]),
                    "target_date": str(r["target_date"]) if r["target_date"] else None
                }
                for r in rows
            ]
            
            # Get subscription costs
            cursor = await db.execute("""
                SELECT COALESCE(SUM(
                    CASE 
                        WHEN billing_cycle = 'monthly' THEN amount
                        WHEN billing_cycle = 'yearly' THEN amount / 12
                        WHEN billing_cycle = 'weekly' THEN amount * 4.33
                        ELSE amount
                    END
                ), 0) as monthly_total
                FROM subscriptions
                WHERE user_id = $1 AND is_active = TRUE
            """, (user_id,))
            row = await cursor.fetchone()
            context["monthly_subscriptions"] = float(row["monthly_total"]) if row else 0
            
            # Calculate net savings potential
            context["net_available"] = context["monthly_income"] - context["monthly_expenses"]
            context["currency"] = CURRENCY_CODE
            context["currency_symbol"] = CURRENCY_SYMBOL
            
        except Exception as e:
            print(f"Error fetching user context: {e}")
            context["error"] = str(e)
        
        return context
    
    async def _handle_conversational_query(
        self,
        query: str,
        db,
        user_id: int
    ) -> NLQueryResponse:
        """
        Handle conversational queries using Gemini AI with user context.
        
        This handles requests like:
        - "Create a budget plan for me"
        - "Tips for saving money"
        - "How can I reduce my spending?"
        """
        # Get user's financial context
        context = await self._get_user_financial_context(db, user_id)
        
        system_instruction = f"""You are FinLens AI, a helpful and knowledgeable personal finance assistant.
You provide practical, actionable financial advice tailored to the user's situation.

IMPORTANT RULES:
1. Always use {CURRENCY_CODE} ({CURRENCY_SYMBOL}) as the currency - never use dollars or other currencies.
2. Be specific and practical - give actual numbers, percentages, and actionable steps.
3. Keep responses focused but comprehensive - aim for 3-5 paragraphs or a clear structured format.
4. If creating a budget/plan, use tables or bullet points for clarity.
5. Reference the user's actual data when relevant to personalize advice.
6. Be encouraging and positive while being realistic.
7. For budget plans, always consider the user's actual income and spending patterns.

USER'S FINANCIAL CONTEXT:
- Monthly Income: {CURRENCY_SYMBOL}{context.get('monthly_income', 0):,.2f}
- Monthly Expenses So Far: {CURRENCY_SYMBOL}{context.get('monthly_expenses', 0):,.2f}
- Net Available: {CURRENCY_SYMBOL}{context.get('net_available', 0):,.2f}
- Total Budget Limits: {CURRENCY_SYMBOL}{context.get('total_budget_limit', 0):,.2f}
- Monthly Subscriptions: {CURRENCY_SYMBOL}{context.get('monthly_subscriptions', 0):,.2f}
- Top Spending Categories: {context.get('top_categories', [])}
- Active Savings Goals: {context.get('goals', [])}
- Budget Categories: {context.get('budgets', [])}

If the user hasn't set up income/budgets yet, acknowledge this and provide general advice that they can customize."""

        prompt = f"""User Question: {query}

Please provide a helpful, detailed response. If they're asking for a plan or strategy, structure it clearly with specific amounts and actionable steps."""

        try:
            response = await self.gemini_client.generate_content(
                prompt=prompt,
                system_instruction=system_instruction
            )
            
            return NLQueryResponse(
                query=query,
                intent="conversational_ai",
                data={"context_used": True, "user_has_data": context.get("monthly_income", 0) > 0},
                explanation=response,
                sql_template_used="AI Financial Advisor",
                confidence=0.9
            )
            
        except Exception as e:
            print(f"Conversational query failed: {e}")
            return NLQueryResponse(
                query=query,
                intent="conversational_ai",
                data={"error": str(e)},
                explanation="I'm sorry, I couldn't process your request right now. Please try again or rephrase your question.",
                sql_template_used="AI Financial Advisor",
                confidence=0.0
            )

    
    async def _classify_intent(self, query: str) -> Dict[str, Any]:
        """
        Classify user intent and extract parameters using AI.
        
        Returns template key and parameters (NOT SQL).
        """
        system_instruction = f"""You are a query intent classifier for a personal finance app.
Given a natural language query, identify:
1. Which SQL template to use (from the list below)
2. What parameters are needed

Available templates:
{chr(10).join(f"- {key}: {info['description']}" for key, info in self.TEMPLATES.items())}

Respond with JSON:
{{
  "template": "template_key",
  "category": "category name if mentioned",
  "time_period": "last 30 days|this month|last month|this week|etc",
  "limit": 10,
  "confidence": 0.85
}}
"""
        
        prompt = f"Classify this query: '{query}'"
        
        try:
            response = await self.gemini_client.generate_structured_content(
                prompt=prompt,
                system_instruction=system_instruction
            )
            
            return response
        except Exception as e:
            print(f"Intent classification failed: {e}")
            # Fallback to simple pattern matching
            return self._fallback_intent(query)
    
    def _fallback_intent(self, query: str) -> Dict[str, Any]:
        """Fallback intent classification using regex."""
        query_lower = query.lower()
        
        # ========== GOALS PATTERNS ==========
        if any(word in query_lower for word in ["goal", "saving", "saved", "progress"]):
            if "track" in query_lower or "on track" in query_lower:
                return {
                    "template": "goals_on_track",
                    "confidence": 0.75
                }
            elif "total" in query_lower or "saved" in query_lower:
                return {
                    "template": "goals_total_saved",
                    "time_period": "this month",
                    "confidence": 0.75
                }
            else:
                return {
                    "template": "goals_progress",
                    "confidence": 0.75
                }
        # ========== SAVINGS PATTERNS (must be before income) ==========
        elif any(word in query_lower for word in ["save", "savings", "afford", "left over", "leftover"]):
            if "how much" in query_lower or "can i" in query_lower or "potential" in query_lower:
                return {
                    "template": "savings_potential",
                    "time_period": "this month",
                    "confidence": 0.8
                }
            else:
                return {
                    "template": "income_vs_expenses",
                    "time_period": "this month",
                    "confidence": 0.75
                }
        
        # ========== INCOME PATTERNS ==========

        elif any(word in query_lower for word in ["income", "earn", "salary", "paycheck"]):
            if "vs" in query_lower or "versus" in query_lower or "compare" in query_lower:
                return {
                    "template": "income_vs_expenses",
                    "time_period": "this month",
                    "confidence": 0.75
                }
            elif "save" in query_lower or "potential" in query_lower:
                return {
                    "template": "savings_potential",
                    "time_period": "this month",
                    "confidence": 0.75
                }
            elif "source" in query_lower or "breakdown" in query_lower:
                return {
                    "template": "income_by_source",
                    "time_period": "this month",
                    "confidence": 0.75
                }
            else:
                return {
                    "template": "income_total",
                    "time_period": "this month",
                    "confidence": 0.75
                }
        
        # ========== SUBSCRIPTION PATTERNS ==========
        elif any(word in query_lower for word in ["subscription", "recurring", "renewal"]):
            if "annual" in query_lower or "yearly" in query_lower or "year" in query_lower:
                return {
                    "template": "subscriptions_annual_cost",
                    "confidence": 0.75
                }
            elif "upcoming" in query_lower or "next" in query_lower or "due" in query_lower:
                return {
                    "template": "subscriptions_upcoming",
                    "confidence": 0.75
                }
            else:
                return {
                    "template": "subscriptions_monthly_total",
                    "confidence": 0.75
                }
        
        # ========== SPLITS PATTERNS ==========
        elif any(word in query_lower for word in ["owe", "owes", "owed", "split", "friend", "settle"]):
            if "who" in query_lower or "owes me" in query_lower:
                return {
                    "template": "splits_owed_to_me",
                    "confidence": 0.75
                }
            elif "pending" in query_lower or "total" in query_lower:
                return {
                    "template": "splits_total_pending",
                    "confidence": 0.75
                }
            else:
                return {
                    "template": "splits_all_friends",
                    "confidence": 0.75
                }
        
        # ========== EXPENSE PATTERNS (original) ==========
        elif "total" in query_lower and "category" in query_lower:
            return {
                "template": "total_by_category",
                "time_period": "last 30 days",
                "confidence": 0.7
            }
        elif "highest" in query_lower or "top" in query_lower or "biggest" in query_lower:
            return {
                "template": "highest_expenses",
                "time_period": "last 30 days",
                "limit": 10,
                "confidence": 0.7
            }
        elif "budget" in query_lower or "over budget" in query_lower:
            return {
                "template": "budget_check",
                "time_period": "this month",
                "confidence": 0.7
            }
        elif "food" in query_lower or "dining" in query_lower:
            return {
                "template": "category_total",
                "category": "Food & Dining",
                "time_period": "last 30 days",
                "confidence": 0.7
            }
        elif "spent" in query_lower or "spending" in query_lower or "expense" in query_lower:
            return {
                "template": "total_in_period",
                "time_period": "last 30 days",
                "confidence": 0.6
            }
        else:
            # Default fallback - try to be helpful
            return {
                "template": "total_in_period",
                "time_period": "last 30 days",
                "confidence": 0.4
            }

    
    def _parse_time_period(self, period_str: str) -> Tuple[date, date]:
        """Convert time period string to start/end dates."""
        today = date.today()
        
        if "last 30 days" in period_str.lower():
            return (today - timedelta(days=30), today)
        elif "this month" in period_str.lower():
            return (date(today.year, today.month, 1), today)
        elif "last month" in period_str.lower():
            if today.month == 1:
                last_month = date(today.year - 1, 12, 1)
            else:
                last_month = date(today.year, today.month - 1, 1)
            # Last day of last month
            end_date = date(today.year, today.month, 1) - timedelta(days=1)
            return (last_month, end_date)
        elif "this week" in period_str.lower():
            start = today - timedelta(days=today.weekday())
            return (start, today)
        else:
            # Default to last 30 days
            return (today - timedelta(days=30), today)
    
    def _extract_params(self, intent: Dict[str, Any], user_id: int) -> Dict[str, Any]:
        """Extract and format parameters from intent."""
        params = {}
        template_key = intent.get("template", "total_in_period")
        
        # User ID is always required
        params["user_id"] = user_id
        
        # Get template to check required params
        template = self.TEMPLATES.get(template_key, {})
        required_params = template.get("params", [])
        
        # Time period - only add if template requires it
        if "start_date" in required_params or "end_date" in required_params:
            if "time_period" in intent:
                start_date, end_date = self._parse_time_period(intent["time_period"])
                params["start_date"] = start_date
                params["end_date"] = end_date
            else:
                # Default to last 30 days
                today = date.today()
                params["start_date"] = today - timedelta(days=30)
                params["end_date"] = today
        
        # Category
        if "category" in required_params:
            if "category" in intent and intent["category"]:
                params["category"] = intent["category"]
            else:
                params["category"] = "Other"  # Default category
        
        # Limit
        if "limit" in required_params:
            if "limit" in intent:
                params["limit"] = intent["limit"]
            else:
                params["limit"] = 10
        
        # Month for budget check
        if "month" in required_params:
            today = date.today()
            params["month"] = f"{today.year}-{today.month:02d}"
        
        return params

    
    async def _execute_query(
        self,
        template_key: str,
        params: Dict[str, Any],
        db
    ) -> List[Dict[str, Any]]:
        """Execute PostgreSQL query with positional parameters."""
        template = self.TEMPLATES[template_key]
        sql = template["sql"]
        param_order = template["params"]
        
        # Build positional parameters tuple
        param_values = tuple(params.get(p) for p in param_order)
        
        # Execute query using positional parameters
        cursor = await db.execute(sql, param_values)
        rows = await cursor.fetchall()
        
        return [dict(row) for row in rows]
    
    async def _generate_explanation(
        self,
        query: str,
        results: List[Dict[str, Any]],
        template_key: str
    ) -> str:
        """Generate natural language explanation of results."""
        
        # Try to generate a smart fallback first in case Gemini fails
        fallback = self._generate_fallback_explanation(results, template_key)
        
        system_instruction = f"""You are a financial assistant explaining query results.
Be concise, clear, and helpful. Focus on insights, not just restating data.
Keep explanations to 1-2 sentences maximum.
IMPORTANT: Always use {CURRENCY_CODE} ({CURRENCY_SYMBOL}) as the currency. Never use dollars ($) or any other currency.
If there's no data, say so helpfully."""
        
        prompt = f"""
Query: "{query}"
Template: {template_key}
Data: {results[:5]}

Explain these financial results in plain English. Be specific with numbers.
"""
        
        try:
            explanation = await self.gemini_client.generate_content(
                prompt=prompt,
                system_instruction=system_instruction
            )
            # If Gemini returns something too generic or short, use fallback
            if len(explanation) < 20 or "result" in explanation.lower():
                return fallback
            return explanation
        except Exception:
            return fallback
    
    def _generate_fallback_explanation(
        self,
        results: List[Dict[str, Any]],
        template_key: str
    ) -> str:
        """Generate template-specific fallback explanations."""
        if not results:
            return "No data found for this query. Try adding some records first!"
        
        row = results[0]  # First result
        
        # Template-specific explanations
        if template_key == "savings_potential":
            income = float(row.get("income", 0) or 0)
            expenses = float(row.get("expenses", 0) or 0)
            net = income - expenses
            if net > 0:
                return f"Based on {CURRENCY_SYMBOL}{income:,.2f} income and {CURRENCY_SYMBOL}{expenses:,.2f} expenses, you could save {CURRENCY_SYMBOL}{net:,.2f} this month."
            elif net < 0:
                return f"You're spending {CURRENCY_SYMBOL}{abs(net):,.2f} more than you earn. Consider reducing expenses."
            else:
                return "Your income and expenses are balanced. No extra savings available."
        
        elif template_key == "income_total":
            total = float(row.get("total_income", 0) or 0)
            count = int(row.get("income_count", 0) or 0)
            return f"Total income: {CURRENCY_SYMBOL}{total:,.2f} from {count} source(s)."
        
        elif template_key == "income_vs_expenses":
            income = float(row.get("income", 0) or 0)
            expenses = float(row.get("expenses", 0) or 0)
            net = float(row.get("net", 0) or 0)
            status = "surplus" if net >= 0 else "deficit"
            return f"Income: {CURRENCY_SYMBOL}{income:,.2f}, Expenses: {CURRENCY_SYMBOL}{expenses:,.2f}. Net {status}: {CURRENCY_SYMBOL}{abs(net):,.2f}."
        
        elif template_key == "goals_progress":
            goals_info = []
            for g in results[:3]:
                name = g.get("name", "Goal")
                progress = float(g.get("progress_percent", 0) or 0)
                goals_info.append(f"{name}: {progress:.0f}%")
            return "Goal progress: " + ", ".join(goals_info) if goals_info else "No active goals found."
        
        elif template_key == "goals_on_track":
            statuses = [f"{r.get('name')}: {r.get('status')}" for r in results[:3]]
            return "Goal status: " + ", ".join(statuses) if statuses else "No active goals."
        
        elif template_key == "goals_total_saved":
            total = float(row.get("total_saved", 0) or 0)
            return f"You've saved {CURRENCY_SYMBOL}{total:,.2f} towards your goals this period."
        
        elif template_key == "subscriptions_monthly_total":
            total = float(row.get("monthly_total", 0) or 0)
            count = int(row.get("subscription_count", 0) or 0)
            return f"Your {count} active subscription(s) cost {CURRENCY_SYMBOL}{total:,.2f}/month."
        
        elif template_key == "subscriptions_annual_cost":
            total = float(row.get("annual_total", 0) or 0)
            return f"Your subscriptions will cost approximately {CURRENCY_SYMBOL}{total:,.2f} per year."
        
        elif template_key == "subscriptions_upcoming":
            if results:
                upcoming = [f"{r.get('name')} in {r.get('days_until')} days" for r in results[:3]]
                return "Upcoming renewals: " + ", ".join(upcoming)
            return "No upcoming subscription renewals in the next 30 days."
        
        elif template_key == "splits_owed_to_me":
            if results:
                owes = [f"{r.get('friend_name')}: {CURRENCY_SYMBOL}{float(r.get('amount_owed', 0)):,.2f}" for r in results[:3]]
                return "Friends who owe you: " + ", ".join(owes)
            return "No one owes you money right now."
        
        elif template_key == "splits_total_pending":
            total = float(row.get("total_pending", 0) or 0)
            count = int(row.get("split_count", 0) or 0)
            return f"You have {CURRENCY_SYMBOL}{total:,.2f} pending across {count} split(s)."
        
        elif template_key == "total_in_period":
            total = float(row.get("total", 0) or 0)
            return f"Total spending: {CURRENCY_SYMBOL}{total:,.2f}."
        
        elif template_key == "highest_expenses":
            if results:
                top = results[0]
                return f"Your biggest expense: {top.get('description', 'Unknown')} at {CURRENCY_SYMBOL}{float(top.get('amount', 0)):,.2f} ({top.get('category', 'Other')})."
            return "No expenses found in this period."
        
        elif template_key == "budget_check":
            over_budget = [r for r in results if float(r.get("remaining", 0) or 0) < 0]
            if over_budget:
                categories = ", ".join([r.get("category", "Unknown") for r in over_budget[:3]])
                return f"You're over budget in: {categories}."
            return "All budgets are on track!"
        
        # Default fallback
        return f"Found {len(results)} result(s) for your query."

    
    async def process_query(
        self,
        query: str,
        db,
        user_id: int
    ) -> NLQueryResponse:
        """
        Process natural language query end-to-end.
        
        HYBRID SYSTEM:
        1. First classify if this is a data query or conversational query
        2. For data queries: Use SQL templates (secure, fast)
        3. For conversational queries: Use Gemini AI with user context
        """
        # Step 0: Classify query type (data vs conversational)
        query_type = self._classify_query_type(query)
        
        # Route conversational queries to AI handler
        if query_type == "conversational":
            return await self._handle_conversational_query(query, db, user_id)
        
        # === DATA QUERY PATH ===
        # Step 1: Classify intent for SQL template selection
        intent = await self._classify_intent(query)
        template_key = intent.get("template", "total_in_period")
        
        # Step 2: Template already selected (from TEMPLATES dict)
        if template_key not in self.TEMPLATES:
            template_key = "total_in_period"  # Fallback
        
        # Step 3: Extract parameters (with user_id)
        params = self._extract_params(intent, user_id)
        
        # Step 4: Execute query
        results = await self._execute_query(template_key, params, db)
        
        # Step 5: Generate explanation
        explanation = await self._generate_explanation(query, results, template_key)
        
        return NLQueryResponse(
            query=query,
            intent=template_key,
            data={"results": results, "count": len(results)},
            explanation=explanation,
            sql_template_used=self.TEMPLATES[template_key]["description"],
            confidence=intent.get("confidence", 0.5)
        )


# Global query engine instance
_query_engine: Optional[QueryEngine] = None


def get_query_engine() -> QueryEngine:
    """Get or create query engine singleton."""
    global _query_engine
    if _query_engine is None:
        _query_engine = QueryEngine()
    return _query_engine
